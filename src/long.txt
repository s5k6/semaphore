Name

    sem — Semaphore interface for the command line


Synopsis

    sem ‹name› [‹args›…] [-- ‹command›…]         # typical usage
    sem -h | less                                # this help
    sem -V                                       # version and license

    The ‘sem’ command offers a versatile, yet simple frontend to named
    system semaphores.  You may initialize, wait, post, or remove a
    semaphore, and run a command in between.


Arguments

    ‹name› — the name of the semaphore to operate on.  May contain
        slashes.  Global, and per-user names reside in different
        namespaces.  See Notes on Names below.  Must be the first
        argument.

    -- ‹command›… ― command to be executed, and its arguments.  This
        must be the last argument, i.e., the douple-dash indicates the
        end of sem's arguments.

    -i ‹num› ― initialize semaphore to ‹num› if it has to be created.
        Without this option, fail if the semaphore does not exist.
        The first process choosen by the OS's scheduler to create the
        semaphore will set the value.  Also see ‘-I’.

    -I ‹num› ― same as ‘-i’, but force creation of semaphore, i.e.,
        fail if it already exists.

    -w ― wait for the semaphore, then execute command.

    -p ― execute command, then post the semaphore.

    -x ― embrace command between a wait and a post.

    -f ― fork into background after waiting, and run any command
        there.  In this case, a potential post operation is also
        performed in the background, after the command.

    -u ― unlink semaphore after a potential wait, just before running
        a potential command.

    -m ‹mode› ― if a new semaphore is created, set mode to ‹mode›.
        The mode must be in the rande 0..0666, i.e., the x-bits cannot
        be set.  Both read and write permission should be granted to
        each class of user that will access the semaphore.

    -g — generate a global name.  Without this option, the semaphore
        resides in a per-user namespace, see Notes on Names below.
        Take care to also set the permissions correctly, see ‘-m’.

    -t ‹time› ― Without ‹time›, or if ‹time› equals 0, switch to
        nonblocking mode, i.e., fail immediately if waiting would
        block.  If ‹time› is positive, time out after blocking for
        ‹time› seconds.  Failure due to timeout is signalled by exit
        code 1.

    -T ‹time› — as ‘-t’, but ‹time› specifies an absolute timeout
        time, given in seconds since the epoch.  Use the ‘date’
        command to calculate this, see examples.

    -l — literally use the semaphore name, i.e., skip the naming magic
        described in Notes on Names below.

    -v ‹level› ― be verbose.  Sets the level of verbosity to the given
        value, or increases by one if no value is given.

    -q — Query semaphore value.  Note, that it is *not* save to rely
        on this information, since it may be outdated by the time of
        printing.  Do not use this unless for debugging purposes!

    -E ‹offset› — offset sem's exit codes by ‹offset›, but leave exit
        codes from the ‹command› alone.  See Notes on Exit Codes
        below.

    -V — show version and license information.


Notes on Names

    On Linux, semaphore names are global, must have an initial slash,
    and must not contain further slashes.  The length is limited to
    251 characters.  The first restriction leads to name clashes
    between different users, the others are annoying.

    ‘sem’ avoids name clashes by prefixing each semaphore name with
    the user's name (or the effective user id if the environment
    variable $USER is unset) and a colon.  The ‘-g’ option disables
    this, creating a “global” name.

    To allow for colons and slashes in the names, ‘sem’ performs a
    poor variant of url-escaping (aka. %-escaping).  Note, that this
    may significantly elongate the name.

    With ‘-v2’, the produced semaphore name is shown.  The option
    ‘-l’ completely disables all conversions, and literally uses the
    semaphore name provided.

    Note, that the operating system may further mangle the semaphore
    name. The command “sem tool%mutex -i1 -v2” may invlove the
    following names (the user is named “sk”):

        Name used by ‘sem’   :  tool%mutex
        Real semaphore name  :  /sk:tool%25mutex
        Name on file system  :  /dev/shm/sem.sk:tool%25mutex

    The ‘-l’ argument only controls the first conversion, i.e., “sem
    /tool%mutex -l -i1” leads to:

        Name used by ‘sem’   :  /tool%mutex
        Real semaphore name  :  /tool%mutex
        Name on file system  :  /dev/shm/sem.tool%mutex

    Thus, permissions provided, you may use the following to remove
    all semaphores from your Linux system.

        shopt -s nullglob; # see bash(1)
        prefix='/dev/shm/sem.'; # see sem_overview(7)
        for i in ${prefix}*; do sem /${i#${prefix}} -l -u -v; done;

Notes on Exit Codes

    If ‘sem’ runs a command in the foreground, it tries to exit with
    the exit code of the command, or one of the following.  To
    disambiguate failure of ‘sem’ from failure of the command, use
    ‘-E’ to offset (i.e., add a constant value to) these codes.  See
    examples.

        0 — All actions have been carried out successfully, and the
            command exited with 0.

        1 — Failed to wait due to timeout or in nonblocking mode.

        2 — Inappropriate usage of ‘sem’, i.e., usage error.

        3 — A systemcall failed.  A more detailed description is given
            in the error message.

        4 — An error in the implementation of ‘sem’.  You should not
            see this.

        5 — The command was killed by a signal.


General Notes

    All messages created by ‘sem’ appear on stderr, and are prefixed
    with the string “sem[‹pid›,‹name›]”, where ‹pid› is replaced by
    the process id, and ‹name› is replaced by the semaphore name.  If
    no name is known, the prefix is just “sem[‹pid›]”.

    If a wait fails, due to timeout or other errors, no further
    actions (unlink, post, running command) are performed, and ‘sem’
    returns with a non-null exit code.

    The ‘sem’ process may replace itself with the command if it does
    not have to wait for the command to return, i.e., if no post is
    requested, and the command is not forked into the background.

    Beware: Debugging synchronization code is difficult.  Testing is
    *not* a sufficient indication of correctness of code.  For really
    cool examples see Downey's Little Book of Semaphores (below).


Examples

    All the following examples use bash(1) syntax, operate on a
    semaphore named “foo”, and run the command “command”. We assume
    “path/*” to point to a bunch of files.

    * To run a command on some files, but make sure only 4 instances
      run at the same time:

          for i in path/*; do
              sem foo -i4 -x -f -- command "${i}";
          done;

      Since ‘sem’ forks only after the waiting, you'll never have more
      than 5 instances of ‘sem’ running, the 5th waiting, and hence
      there are at most 4 of the commands running.


    * If multiple commands need to be run, use separate instances of
      ‘sem’ for waiting and posting.  This is bash syntax creating a
      subshell for each file, but never more than four at the same
      time:

          for i in path/*; do
              sem foo -i4 -w -v;
              ( command1 "${i}";
                command2 "${i}";
                sem foo -p -v;
              )&                          # note the ampersand
          done;

      Since the waiting happens before invocation of the subshell,
      you'll never have more than 4 subshells running.


    * If you want ‘sem’ to bail out after waiting for one minute, use

          sem foo -t 60 -w

      If you want to time out at tea time on a certain Friday in
      April of the year 2077, you may use the ‘date’ command to
      calculate the seconds since the epoch.

          sem foo -T $(date -d '2077-4-30 17:00' +%s) -w


    * Use of ‘-E’ to find out whether ‘sem’ failed, or the command:

          sem foo -E100 -t -x -- sh -c 'exit 42';
          ec="${?}";
          if test "${ec}" -gt 100; then
             echo "sem exit code is $((ec-100))";
          else
             echo "command returned ${ec}";
          fi;


See also

    sem_overview(7)

    Allen B. Downey.  The Little Book of Semaphores.  Green Tea Press.
    http://www.greenteapress.com/semaphores/index.html
